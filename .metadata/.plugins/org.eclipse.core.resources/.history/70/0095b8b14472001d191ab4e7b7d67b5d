/*
 * stm32f407xx_spi_driver.c
 *
 *  Created on: 24 Nov 2022
 *      Author: ViralPatel
 */

#include "stm32f407xx_spi_driver.h"


void SPI_PeriClockControl(SPI_RegDef_t *pSPIx, uint8_t EnorDi)
{
	if (EnorDi == ENABLE)
	{
			if (pSPIx == SPI1)
			{
				SPI1_PCLK_EN();
			}
			else if (pSPIx == SPI2)
			{
				SPI2_PCLK_EN();
			}
			else if (pSPIx == SPI3)
			{
				SPI3_PCLK_EN();
			}
	}
	else
	{
			if (pSPIx == SPI1)
			{
				SPI1_PCLK_DI();
			}
			else if (pSPIx == SPI2)
			{
				SPI2_PCLK_DI();
			}
			else if (pSPIx == SPI3)
			{
				SPI3_PCLK_DI();
			}
	}
}

/*
 * 	Init and Deint of the peripheral
 */
void SPI_Init(SPI_Handle_t *pSPIHandle)
{
	//first lets configgure the spi_cr1 register
	uint32_t tempreg = 0;

	//1. configure the device mode
	tempreg |= pSPIHandle -> SPIConfig.SPI_DeviceMode <<SPI_CR1_MSTR;

	//2. configure the bus config
	if(pSPIHandle->SPIConfig.SPI_BusConfig == SPI_BUS_CONFIG_FD)
	{
		//bidi mode should be cleared
		tempreg &=~(1<<SPI_CR1_BIDIMODE);
	}
	else if (pSPIHandle->SPIConfig.SPI_BusConfig == SPI_BUS_CONFIG_HD)
	{
		// bidi mode should be set
		tempreg|=(1<<SPI_CR1_BIDIMODE);
	}
	else if(pSPIHandle->SPIConfig.SPI_BusConfig == SPI_BUS_CONFIG_SIMPLEX_RXONLY)
	{
		// bisi mode should be cleared
		tempreg &=~(1<<SPI_CR1_BIDIMODE);
		//rxonly bit must be selected
		tempreg |=(1<<SPI_CR1_RXONLY);
	}

	//3. configure the spi serial clock speed(baud rate)
	tempreg |= pSPIHandle->SPIConfig.SPI_SclkSpeed<<SPI_CR1_BR;

	//4. configure the DFF
	tempreg |= pSPIHandle->SPIConfig.SPI_DFF<<SPI_CR1_DFF;

	//5. configure the CPOL
	tempreg |= pSPIHandle-> SPIConfig.SPI_CPOL<<SPI_CR1_CPOL;

	//6. configure the CPHA
	tempreg |= pSPIHandle->SPIConfig.SPI_CPHA<<SPI_CR1_CPHA;

	pSPIHandle->pSPIx->CR1=tempreg;

}


void SPI_DeInt(SPI_RegDef_t *pSPIx)
{
	if (pSPIx == SPI1) {
			SPI1_REG_RESET();
		} else if (pSPIx == SPI2) {
			SPI2_REG_RESET();
		} else if (pSPIx == SPI3) {
			SPI3_REG_RESET();
		}
}

uint8_t SPI_GetFlagStatus(SPI_RegDef_t *pSPIx, uint32_t FlagName)
{
	if(pSPIx->SR & FlagName)
	{
		 return FLAG_SET;
	}
	return FLAG_RESET;
}

// data send and receive using the spi pin

// blocking(non interrupts) and non blocking the api

void SPI_SendData(SPI_RegDef_t *pSPIx, uint8_t *pTxBuffer, uint32_t Len)
{
	while(Len>0)
	{
		//1. wait until TXE is set
		while(SPI_GetFlagStatus(pSPIx, SPI_TXE_FLAG) == FLAG_RESET);

		//2. check the DFF bit in CR1
		if((pSPIx->CR1 & (1<<SPI_CR1_DFF)))
		{
			//16 bit DFF
			//1. Load the data in to the DR
			pSPIx->DR = *((uint16_t*)pTxBuffer);
			Len--;
			Len--;			//the len is decreae by 2 because of the 16 bit
			(uint16_t*)pTxBuffer++;
		}
		else
		{
			//8 bit DFF
			//1. Load the data in to the DR
			pSPIx->DR = *pTxBuffer;
			Len--;					// the len is decrease by 1 bcoz of 8 bbit
			pTxBuffer++;
		}

	}
}


void SPI_ReceiveData(SPI_RegDef_t *pSPIx,uint8_t *pRxBuffer, uint32_t Len)
{
	while(Len>0)
	{
		//1. wait until RXE is set
		while(SPI_GetFlagStatus(pSPIx, SPI_RXNE_FLAG) == FLAG_RESET);

		//2. check the DFF bit in CR1
		if((pSPIx->CR1 & (1<<SPI_CR1_DFF)))
		{
			//16 bit DFF
			//1. Load the data froim DR to RX buffer
			*((uint16_t*)pRxBuffer) = pSPIx->DR ;
			Len--;
			Len--;			//the len is decreae by 2 because of the 16 bit
			(uint16_t*)pRxBuffer++;
		}
		else
		{
			//8 bit DFF
			//1. Load the data from DR to Rxbuffer address
			*pRxBuffer=pSPIx->DR;
			Len--;					// the len is decrease by 1 bcoz of 8 bbit
			pRxBuffer++;
		}

	}
}


void SPI_IRQConfig(uint8_t IRQNumber, uint8_t EnorDi)
{
	if(EnorDi == ENABLE)
	{
		if(IRQNumber <=31)
		{
			// program ISER0 Register
			*NVIC_ISER0 |=(1<<IRQNumber);

		}
		else if (IRQNumber>31 && IRQNumber<64)
		{
			// Program the ISER1 Register
			*NVIC_ISER1 |= (1<<(IRQNumber%32));
		}
		else if(IRQNumber>=64 && IRQNumber<96)
		{
			// Program the ISER2 register
			*NVIC_ISER3 |=(1<<(IRQNumber%64));
		}
	}
	else
	{
		if(IRQNumber <=31)
		{
			*NVIC_ICER0 |=(1<<IRQNumber);
		}
		else if (IRQNumber>31 && IRQNumber<64)
		{
			*NVIC_ICER1 |=(1<<(IRQNumber%32));
		}
		else if(IRQNumber>=64 && IRQNumber<96)
		{
			*NVIC_ICER3 |=(1<<(IRQNumber%64));
		}
	}
}

void SPI_IRQPriorityConfig(uint8_t IRQNumber,uint32_t IRQPriority)
{
	//1. first lets find out the ipr register
	uint8_t iprx = IRQNumber/4;
	uint8_t iprx_section = IRQNumber%4;
	uint8_t shift_amount = (8*iprx_section)+(8-NO_PR_BITS_IMPLEMENTED);
	*(NVIC_PR_BASE_ADDR + (iprx)) |= (IRQPriority<< shift_amount);
}

uint8_t SPI_SendDataIT(SPI_Handle_t *pSPIHandle, uint8_t *pTxBuffer, uint32_t Len)
{
	uint8_t state=pSPIHandle->TxState;
	if(state!=SPI_Busy_IN_TX)
	{
	// 1. save the tx buffer address and len information in some global variable
	pSPIHandle->pTxBuffer = pTxBuffer;
	pSPIHandle->TxLen = Len;

	//2. Mark the spi state as busy in transmission so tthat no other code can take over the spi code
	pSPIHandle->TxState = SPI_Busy_IN_TX;

	//3. Enable the TXEI control bit to get intterrupt whenever TXE flag is set in SR
	pSPIHandle->pSPIx->CR2 |= (1<<SPI_CR2_TXEIE);

	//4. Data transmissoin will be handled by the ISR code
	}
	return state;
}
uint8_t SPI_ReceiveDataIT(SPI_Handle_t *pSPIHandle,uint8_t *pRxBuffer, uint32_t Len)
{
	uint8_t state=pSPIHandle->RxState;
	if(state!=SPI_Busy_IN_RX)
	{
	// 1. save the tx buffer address and len information in some global variable
	pSPIHandle->pRxBuffer = pRxBuffer;
	pSPIHandle->RxLen = Len;

	//2. Mark the spi state as busy in transmission so tthat no other code can take over the spi code
	pSPIHandle->RxState = SPI_Busy_IN_RX;

	//3. Enable the TXEI control bit to get intterrupt whenever TXE flag is set in SR
	pSPIHandle->pSPIx->CR2 |= (1<<SPI_CR2_RXNEIE);

	//4. Data transmissoin will be handled by the ISR code
	}
	return state;
}

void SPI_IRQHandling(SPI_Handle_t *pHandle)
{
	uint8_t temp1, temp2;
	// lets check for the TXE why the interrupt happened
	temp1 = pHandle->pSPIx->SR & (1<<SPI_SR_TXE);
	temp2 = pHandle->pSPIx->CR2 & (1<< SPI_CR2_TXEIE);

	if(temp1 && temp2)
	{
		//handle TXE
		spi_txe_interrupt_handle();
	}
	// lets check for the RXNE why the interrupt happened
	temp1 = pHandle->pSPIx->SR & (1<<SPI_SR_RXNE);
	temp2 = pHandle->pSPIx->CR2 & (1<< SPI_CR2_RXNEIE);

	if(temp1 && temp2)
	{
		//handle rxne
		spi_rxne_interrupt_handle();
	}

	//check for ovr flag
	temp1 = pHandle-> pSPIx->SR & (1<<SPI_SR_OVR);
	temp2 = pHandle-> pSPIx-> CR2 & (1<<SPI_CR2_ERRIE);

	if(temp1 && temp2)
	{
		//handle ovr error
		spi_ovr_err_interrupt_handle();
	}
}


void SPI_PeripheralControl(SPI_RegDef_t *pSPIx, uint8_t EnOrDi)
{
	if(EnOrDi ==ENABLE)
	{
		 pSPIx->CR1 |= (1<<SPI_CR1_SPE); 			//this enables the SPI
	}
	else
	{
		pSPIx->CR1 &= ~(1<<SPI_CR1_SPE);			//this disables the SPI
	}
}

void SPI_SSIConfig(SPI_RegDef_t *pSPIx, uint8_t EnOrDi)
{
	if(EnOrDi ==ENABLE)
	{
		 pSPIx->CR1 |= (1<<SPI_CR1_SSI); 			//this enables the SPI
	}
	else
	{
		pSPIx->CR1 &= ~(1<<SPI_CR1_SSI);			//this disables the SPI
	}
}

void SPI_SSOEConfig(SPI_RegDef_t *pSPIx, uint8_t EnOrDi)
{
	if(EnOrDi ==ENABLE)
	{
		 pSPIx->CR1 |= (1<<SPI_CR2_SSOE); 			//this enables the SPI
	}
	else
	{
		pSPIx->CR1 &= ~(1<<SPI_CR2_SSOE);			//this disables the SPI
	}
}

//helper private funciton to help the code ni order to make it work

static void spi_txe_interrupt_handle(SPI_Handle_t *pSPIHandle)			// staic is used to make the function private//
{
	if((pSPIHandle->pSPIx->CR1 & (1<<SPI_CR1_DFF)))
		{
				//16 bit DFF
				//1. Load the data in to the DR
				*((uint16_t*)pSPIHandle->pSPIx->DR = *((uint16_t*)pSPIHandle->pTxBuffer));
				pSPIHandle->TxLen--;
				pSPIHandle->TxLen--;			//the len is decreae by 2 because of the 16 bit
				(uint16_t*)pSPIHandle->pTxBuffer++;
		}
	else
		{
				//8 bit DFF
				//1. Load the data in to the DR
		pSPIHandle->pSPIx->DR = *pSPIHandle->pTxBuffer;
		pSPIHandle->TxLen--;
		pSPIHandle->pTxBuffer++;
		}

	if(!pSPIHandle->TxLen)
	{
		// if txlen is zero, close the spi communication and inform the application that tx is over
		SPI_CloseTransmission(pSPIHandle);
		SPI_ApplicationEventCallback(pSPIHandle,SPI_EVENT_TX_CMPLT);

	}
}
static void spi_rxne_interrupt_handle(SPI_Handle_t *pSPIHandle)
{
	if((pSPIHandle->pSPIx->CR1 & (1<<11)))
		{
				//16 bit DFF
				//1. Load the data in to the DR
				*((uint16_t*)pSPIHandle->pSPIx->DR = *((uint16_t*)pSPIHandle->pRxBuffer));
				pSPIHandle->RxLen--;
				pSPIHandle->RxLen--;			//the len is decreae by 2 because of the 16 bit
				(uint16_t*)pSPIHandle->pRxBuffer++;
		}
	else
		{
				//8 bit DFF
				//1. Load the data in to the DR
		pSPIHandle->pSPIx->DR = *pSPIHandle->pRxBuffer;
		pSPIHandle->RxLen--;
		pSPIHandle->pRxBuffer++;
		}

	if(!pSPIHandle->RxLen)
	{
		// reception is complete
		// lets turn off the rxneie interrupt
		SPI_CloseReception(pSPIHandle);
		SPI_ApplicationEventCallback(pSPIHandle,SPI_EVENT_RX_CMPLT);

	}
}
static void spi_ovr_err_interrupt_handle(SPI_Handle_t *pSPIHandle)
{
	uint8_t tmep;
	//1. clear the ovr flag
	if(pSPIHandle->TxState !=SPI_Busy_IN_TX)
	{
		temp=pSPIHandle->pSPIx->DR;
		temp=pSPIHandle->pSPIx->SR;
	}
	(void)temp;
	//2. inform the application
	SPI_ApplicationEventCallback(pSPIHandle,SPI_EVENT_OVR_ERR);
}

void SPI_CloseTransmission(SPI_Handle_t *pSPIHandle)
{
	pSPIHandle->pSPIx->CR2 &=~(1<<SPI_CR2_TXEIE);
	pSPIHandle->pTxBuffer = NULL;
	pSPIHandle->TxLen =0;
	pSPIHandle->TxState = SPI_Ready;
}
void SPI_CloseReception(SPI_Handle_t* pSPIHandle)
{
	pSPIHandle->pSPIx->CR2 &=~(1<<SPI_CR2_RXNEIE);
	pSPIHandle->pRxBuffer = NULL;
	pSPIHandle->RxLen =0;
	pSPIHandle->RxState = SPI_Ready;
}

void SPI_ClearOVRFlag(SPI_RegDef_t *pSPIx)
{
	uint8_t temp;
	temp = pSPIx->DR;
	temp = pSPIx->SR;
	(void)temp;
}
