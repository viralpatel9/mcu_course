/*
 * stm32f407xx_gpio_driver.c
 *
 *  Created on: Nov 6, 2022
 *      Author: ViralPatel
 */


#include "stm32f407xx_gpio_driver.h"



/***************************************
 *
 * @fn 				- GPIO_PeriClockControl
 *
 * @brief			- This function enable oo disable the the peripheral clock fo rthe given GPIO
 *
 * @param[in]		- base address of the GPIO Peripheral
 * @param[in]		- ENABLE or DISABLE macros
 * @param[in]		-
 *
 * @return 			-  None
 *
 * @Note			-  None
 *
 *
*************************************** */

void GPIO_PeriClockControl(GPIO_RegDef_t *pGPIOx, uint8_t EnorDi)
{
	if(EnorDi == ENABLE)
	{
		if(pGPIOx == GPIOA)
				{
					GPIOA_PCLK_EN();
				}
		else if (pGPIOx == GPIOB)
				{
					GPIOB_PCLK_EN();
				}
		else if (pGPIOx == GPIOC)
				{
					GPIOC_PCLK_EN();
				}
		else if (pGPIOx == GPIOD)
				{
					GPIOD_PCLK_EN();
				}
		else if (pGPIOx == GPIOE)
				{
					GPIOE_PCLK_EN();
				}
		else if (pGPIOx == GPIOF)
				{
					GPIOF_PCLK_EN();
				}
		else if (pGPIOx == GPIOG)
				{
					GPIOG_PCLK_EN();
				}
		else if (pGPIOx == GPIOH)
				{
					GPIOH_PCLK_EN();
				}
		else if (pGPIOx == GPIOI)
				{
					GPIOI_PCLK_EN();
				}
	}
	else
	{
		if(pGPIOx == GPIOA)
				{
					GPIOA_PCLK_DI();
				}
		else if (pGPIOx == GPIOB)
				{
					GPIOB_PCLK_DI();
				}
		else if (pGPIOx == GPIOC)
				{
					GPIOC_PCLK_DI();
				}
		else if (pGPIOx == GPIOD)
				{
					GPIOD_PCLK_DI();
				}
		else if (pGPIOx == GPIOE)
				{
					GPIOE_PCLK_DI();
				}
		else if (pGPIOx == GPIOF)
				{
					GPIOF_PCLK_DI();
				}
		else if (pGPIOx == GPIOG)
				{
					GPIOG_PCLK_DI();
				}
		else if (pGPIOx == GPIOH)
				{
					GPIOH_PCLK_DI();
				}
		else if (pGPIOx == GPIOI)
				{
					GPIOI_PCLK_DI();
				}
	}
}

/*
 * 	Init and Deint of the peripheral
 */
void GPIO_Init(GPIO_Handle_t *pGPIOHandle)
{
	uint32_t temp=0;
	// Configure the mode of the GPIO pin
	if(pGPIOHandle -> GPIO_PinConfig.GPIO_PinMode <= GPIO_MODE_ANALOG)
	{
		//the non interrupt mode
		temp= (pGPIOHandle -> GPIO_PinConfig.GPIO_PinMode <<( 2*pGPIOHandle ->GPIO_PinConfig.GPIO_PinNumber));
		pGPIOHandle->pGPIOx ->MODER &= ~(0x03 << pGPIOHandle ->GPIO_PinConfig.GPIO_PinNumber);   // cleraing off the pin number before using it
		pGPIOHandle->pGPIOx ->MODER|=temp;			//setting

	}
	else
	{
		// this is the interrupt mode
	}
	temp=0;

	// Configure the speed
	temp = (pGPIOHandle -> GPIO_PinConfig->GPIO_PinSpeed <<(2 *pGPIOHandle ->GPIO_PinConfig.GPIO_PinNumber));
	pGPIOHandle->pGPIOx ->OSPEEDR &= ~(0x03 << pGPIOHandle ->GPIO_PinConfig.GPIO_PinNumber);
	pGPIOHandle->pGPIOx ->OSPEEDR|=temp;

	temp=0;

	// Configure the pupd settings
	temp = (pGPIOHandle -> GPIO_PinConfig->GPIO_PinPuPdControl <<(2 *pGPIOHandle ->GPIO_PinConfig.GPIO_PinNumber));
	pGPIOHandle->pGPIOx ->PUPDR &= ~(0x03 << pGPIOHandle ->GPIO_PinConfig.GPIO_PinNumber);
	pGPIOHandle->pGPIOx ->PUPDR|=temp;

	temp=0;

	//configure the output type
	temp = (pGPIOHandle -> GPIO_PinConfig->GPIO_PinOPType <<(2 *pGPIOHandle ->GPIO_PinConfig.GPIO_PinNumber));
	pGPIOHandle->pGPIOx ->OTYPER &= ~(0x1 << pGPIOHandle ->GPIO_PinConfig.GPIO_PinNumber);
	pGPIOHandle->pGPIOx ->OTYPER|=temp;

	temp=0;

	// configure the alternate functionality
	if(pGPIOHandle-> GPIO_PinConfig.GPIO_PinMode == GPIO_MODE_ALTFN)
	{
		uint32_t temp1, temp2;

		temp1= pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber /8;
		temp2= pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber %8;
		pGPIOHandle->pGPIOx ->AFR[temp1] &= ~(0xF <<(4*temp2));
		pGPIOHandle->pGPIOx ->AFR[temp1] |= (pGPIOHandle->GPIO_PinConfig->GPIO_PinAltFunMode<<(4*temp2));
	}
}

void GPIO_DeInt(GPIO_RegDef_t *pGPIOx)
{
		if(pGPIOx == GPIOA)
				{
					GPIOA_REG_RESET();
				}
		else if (pGPIOx == GPIOB)
				{
					GPIOB_REG_RESET();
				}
		else if (pGPIOx == GPIOC)
				{
					GPIOC_REG_RESET();
				}
		else if (pGPIOx == GPIOD)
				{
					GPIOD_REG_RESET();
				}
		else if (pGPIOx == GPIOE)
				{
					GPIOE_REG_RESET();
				}
		else if (pGPIOx == GPIOF)
				{
					GPIOF_REG_RESET();
				}
		else if (pGPIOx == GPIOG)
				{
					GPIOG_REG_RESET();
				}
		else if (pGPIOx == GPIOH)
				{
					GPIOH_REG_RESET();
				}
		else if (pGPIOx == GPIOI)
				{
					GPIOI_REG_RESET();
				}

}


/*
 * Data read and write
 */

uint8_t GPIO_ReadFromInputPin(GPIO_RegDef_t *pGPIOx, uint8_t PinNumber)
{
;
}

uint16_t GPIO_ReadFromInputPort(GPIO_RegDef_t *pGPIOx)
{
;
}

void GPIO_WriteToOutputPin(GPIO_RegDef_t *pGPIOx, uint8_t PinNumber, uint8_t Value)
{
;
}

void GPIO_WriteToOutputPort(GPIO_RegDef_t *pGPIOx, uint16_t Value)
{
;
}

void GPIO_ToggleOutputPin(GPIO_RegDef_t *pGPIOx, uint8_t PinNumber)

/*
 * IRQ Configuration and ISR Handling
 */
void GPIO_IRQConfig(uint8_t IRQNumber, uint8_t IRQPriority, uint8_t EnorDi)
void GPIO_IRQHandling(uint8_t PinNumber)
